// Generated by CoffeeScript 2.0.2
var fs, watch;

({watch} = require('chokidar'));

fs = require('fs-extra');

module.exports = function(punk) {
  var reporter, startPipe;
  reporter = punk.reporter;
  startPipe = async function(files, task) {
    var devnull, pipe, ref;
    ref = task.pipes;
    // pass files through pipes
    for (devnull in ref) {
      pipe = ref[devnull];
      await files.pipe(pipe);
    }
    // convert files
    if (task.to && !(task.outFile || task.outDir || task.outDirectory)) {
      await files.pipe(punk.p.to(task.to));
      task.outDir = './';
      await files.pipe(punk.p.write(task));
    } else if (task.to) {
      await files.pipe(punk.p.to(task.to));
    }
    if (task.min) {
      await files.pipe(punk.p.min());
    }
    // write files to FS
    return (await files.pipe(punk.p.write(task)));
  };
  punk._runTask = async function(taskName, task) {
    var files;
    reporter.startingTask(taskName);
    // set settings to standard format
    task = punk.d.toSetting(task);
    files = new punk.Collection(void 0, task);
    // load files
    await files.pipe(punk.p.add(task.entry));
    await startPipe(files, task);
    // report
    reporter.finishedTask(taskName);
  };
  return punk._watchTask = async function(taskName, task) {
    var ch, changed, notRunning, running, sleep, watcher;
    // r._runTask taskName, task
    // set settings to standard format
    task = punk.d.toSetting(task);
    running = false;
    // load files
    changed = async function(rg) {
      var files;
      files = new punk.Collection(void 0, task);
      if (rg) {
        await files.pipe(punk.p.add([rg]));
      } else {
        await files.pipe(punk.p.add(task.entry));
      }
      await startPipe(files, task);
      if (rg) {
        reporter.changed(rg);
      }
    };
    notRunning = function() {
      return setTimeout(function() {
        return running = false;
      }, punk.config.changedDelay + 10);
    };
    sleep = function(time) {
      return new Promise(function(r, j) {
        return setTimeout(function() {
          return r();
        }, time);
      });
    };
    ch = async function(event, path) {
      if (!running) {
        running = true;
        await changed(path);
        return notRunning();
      }
    };
    watcher = watch(task.entry);
    watcher.on('all', ch);
  };
};
