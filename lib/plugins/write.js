// Generated by CoffeeScript 2.1.1
var fs, path;

path = require('path');

fs = require('fs-extra');

module.exports = function(recess) {
  var plugin, reporter;
  reporter = recess.reporter;
  plugin = {};
  plugin.pipes = {
    write: function(setting) {
      // PIPE #
      return recess.i.buffer(async function(files, cond) {
        var out, ref, ref1, ref2, ref3, workdir;
        workdir = setting.workdir || cond.workdir || './';
        if (files.length === 1 && ((ref = setting.outFile) != null ? ref.length : void 0)) {
          if (setting.outFile[0] === recess.s.entry) {
            setting.outFile = setting.entry;
          }
          await recess.d.eachAsync(setting.outFile, async function(pth) {
            var out, rg, to;
            if (files[0].contents !== void 0) {
              out = path.resolve(workdir, pth);
              to = recess.d.getExt(out);
              rg = recess.d.getType(files[0]);
              if (to !== rg) {
                files = (await recess.p.to(to, false)(files, cond));
              }
              await fs.remove(out);
              return (await fs.writeFile(out, files[0].contents, {
                mode: files[0].stat.stat.mode
              }));
            }
          });
        } else if (files.length === 0) {

        } else if (((ref1 = setting.outDir) != null ? ref1.length : void 0) || (!((ref2 = setting.outDir) != null ? ref2.length : void 0) && (setting.to != null))) {
          if (!((ref3 = setting.outDir) != null ? ref3.length : void 0) && (setting.to != null)) {
            out = [workdir];
          } else {
            out = setting.outDir;
          }
          // if there are multiple files, write they to directory, which specified in setting.outDir
          await recess.d.eachAsync(out, async function(dir) {
            return (await recess.d.eachAsync(files, async function(file) {
              var realPath;
              // absolute path
              if (file.contents !== void 0) {
                realPath = path.resolve(workdir, dir, file.path);
                await fs.remove(realPath);
                await fs.mkdirp(path.dirname(realPath));
                await fs.writeFile(realPath, file.contents, {
                  mode: files[0].stat.stat.mode
                });
              }
            }));
          });
        }
        return files;
      });
    },
    outFile: function(setting) {
      if (!Array.isArray(setting)) {
        setting = [setting];
      }
      return async function(files, cond) {
        return (await plugin.pipes.write({
          outFile: setting
        })(files, cond));
      };
    },
    outDir: function(setting) {
      if (!Array.isArray(setting)) {
        setting = [setting];
      }
      return async function(files, cond) {
        return (await plugin.pipes.write({
          outDir: setting
        })(files, cond));
      };
    }
  };
  plugin.pipes.outDirectory = plugin.pipes.outDir;
  plugin.pipes.dest = plugin.pipes.write;
  return plugin;
};
