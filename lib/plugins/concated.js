// Generated by CoffeeScript 2.1.1
var Mode, assign, babelify, browserify, fs, globby, ignore, mm, normalize, path, relative;

path = require('path');

fs = require('fs-extra');

globby = require('globby');

ignore = require('ignore');

path = require('path');

browserify = require('browserify');

babelify = require('babelify');

mm = require('micromatch');

path = require('path');

relative = require('relative');

path = require('path');

fs = require('fs-extra');

assign = require('deep-assign');

Mode = require('stat-mode');

path = require('path');

fs = require('fs-extra');

normalize = function(mode) {
  var called, i, key, len, newMode, ref;
  called = false;
  newMode = {
    owner: {},
    group: {},
    others: {}
  };
  ref = ['read', 'write', 'execute'];
  for (i = 0, len = ref.length; i < len; i++) {
    key = ref[i];
    if (!(typeof mode[key] === 'boolean')) {
      continue;
    }
    newMode.owner[key] = mode[key];
    newMode.group[key] = mode[key];
    newMode.others[key] = mode[key];
    called = true;
  }
  if (called) {
    return newMode;
  } else {
    return mode;
  }
};

module.exports = function(recess) {
  var plugin, reporter;
  reporter = recess.reporter;
  plugin = {};
  plugin.pipes = {
    add: (settings) => {
      if (!Array.isArray(settings)) {
        settings = [settings];
      }
      // PIPE #
      return recess.i.any(async function(files, cond) {
        var glb, ig, paths;
        // get paths
        if (settings.length !== 0) {
          ig = ignore().add(recess.ignored);
          glb = globby.sync(settings, {
            cwd: cond.workdir
          });
          paths = ig.filter(glb);
          // no files at input
          if ((paths.length === 0) && (glb.length === paths.length)) {
            reporter.noFiles(settings);
          }
          // load files
          await recess.d.eachAsync(paths, async function(pth) {
            var contents;
            contents = (await fs.readFile(path.resolve(cond.workdir, pth)));
            files.push(new recess.File(pth, contents));
          });
        }
        return files;
      });
    },
    bundle: function(bws = {
        presets: ["env", "vue-app"]
      }, bbs) {
      // PIPE #
      return recess.i.stream(async function(files) {
        await recess.d.eachAsync(files, function(file) {
          return new Promise(function(resolve, reject) {
            var bundle, bws2;
            // new browserify bundle
            bws2 = Object.assign({
              basedir: path.dirname(file.path)
            }, bws);
            bundle = browserify(file.contents, bws); // set cwd to file name
            
            // add babelify
            bundle.transform(babelify, bbs);
            // start bundling
            return bundle.bundle(function(err, b) {
              if (err) {
                // throw error
                reporter.error(err);
              }
              file.contents = b;
              return resolve();
            });
          });
        });
        return files;
      });
    },
    concat: function(settings, separator) {
      // set settings to standard form
      if ((separator != null) && typeof settings !== 'object') {
        settings = {
          output: settings,
          separator: separator
        };
      } else if (typeof settings !== 'object') {
        settings = {
          output: settings,
          separator: ''
        };
      } else {
        reporter.error(new Error('Settings not defined!'));
      }
      
      // PIPE #
      return recess.i.buffer(function(files) {
        var file, i, joinList, len, out, r;
        separator = Buffer.from(settings.separator);
        // buffer concat list
        joinList = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          joinList.push(file.contents, separator);
        }
        joinList.pop();
        out = Buffer.concat(joinList);
        // new file storage
        r = [];
        r.push(new recess.File(settings.output, out));
        return r;
      });
    },
    convert: function(settings, tr) {
      var ref;
      if ((ref = typeof settings) !== 'number' && ref !== 'string') {
        reporter.error('Setting must be a number or string!');
      }
      return recess.i.buffer(async function(files, cond) {
        var r;
        r = (await recess.d.mapAsync(files, async function(file) {
          var collection, ext, pipe;
          ext = recess.d.getType(file);
          // if there's needed converter
          if (recess.converters[ext] && recess.converters[ext][settings]) {
            pipe = recess.converters[ext][settings];
            collection = recess.collection([file], cond);
            await collection.pipe(pipe);
            file = collection.files[0];
            file.setExt(settings);
            // pipe file
            return file;
          } else if (ext === settings) {
            return file;
          } else if (tr) {

          } else {
            // remove file
            reporter.noConverter(file.path, settings);
            return file;
          }
        }));
        return r;
      });
    },
    pif: function(settings) {
      return recess.i.any(async function(files, cond) {
        await recess.d.eachAsync(settings, async function(pipe, name) {
          var collection, file, filtered, flt, i, id, keys, len, results;
          keys = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = files.length; i < len; i++) {
              file = files[i];
              results.push(file.path);
            }
            return results;
          })();
          filtered = mm(keys, name);
          results = [];
          for (i = 0, len = filtered.length; i < len; i++) {
            flt = filtered[i];
            for (id in files) {
              file = files[id];
              if (file.path === flt) {
                file = file;
              }
            }
            collection = recess.collection([file], cond);
            await collection.pipe(pipe);
            file = collection.files[0];
            results.push(files[id] = file);
          }
          return results;
        });
        return files;
      });
    },
    minify: function(settings) {
      return recess.i.buffer(async function(files, cond) {
        var r;
        r = (await recess.d.mapAsync(files, async function(file) {
          var collection, ext, pipe;
          ext = recess.d.getType(file);
          // if there's needed converter
          if (recess.minifiers[ext]) {
            // find converter
            pipe = recess.minifiers[ext];
            collection = recess.collection([file], cond);
            await collection.pipe(pipe);
            file = collection.files[0];
            // pipe file
            return file;
          } else {
            // remove file
            reporter.noMin(file.path);
          }
        }));
        return r;
      });
    },
    mute: function(files) {
      if (files) {
        return [];
      } else {
        return function() {
          return [];
        };
      }
    },
    wrap: (settings) => {
      // PIPE #
      return recess.i.any(function(files, cond) {
        var file, i, len;
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          file.path = relative(cond.workdir, file.path);
          file.path = path.join(settings, file.path);
        }
        return files;
      });
    },
    unwrap: (reg, str = "") => {
      // PIPE #
      return recess.i.any(function(files, cond) {
        var file, i, len, xp;
        xp = new RegExp(reg + '/?');
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          file.path = file.path.replace(xp, str);
        }
        return files;
      });
    },
    del: function() {
      return recess.i.any(async function(files, cond) {
        await recess.d.eachAsync(files, async function(file) {
          var pth;
          pth = path.resolve(cond.workdir, file.path);
          return (await fs.remove(pth));
        });
        return files;
      });
    },
    stat: function(stat) {
      if (typeof stat === 'object') {
        stat = normalize(stat);
      }
      return recess.i.any(function(files, cond) {
        var file, i, len;
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          if (typeof stat === 'number') {
            file.stat = stat;
          } else {
            assign(file.stat, stat);
          }
        }
        return files;
      });
    },
    header: function(settings) {
      return recess.i.buffer(async function(files, cond) {
        var b;
        b = Buffer.from(settings);
        await recess.d.eachAsync(files, function(file) {
          return file.contents = Buffer.concat([b, file.contents]);
        });
        return files;
      });
    },
    footer: function(settings) {
      return recess.i.buffer(async function(files, cond) {
        var b;
        b = Buffer.from(settings);
        await recess.d.eachAsync(files, function(file) {
          return file.contents = Buffer.concat([file.contents, b]);
        });
        return files;
      });
    },
    write: function(setting) {
      // PIPE #
      return recess.i.buffer(async function(files, cond) {
        var out, ref, ref1, workdir;
        workdir = setting.workdir || cond.workdir || './';
        if (files.length === 1 && ((ref = setting.outFile) != null ? ref.length : void 0)) {
          if (setting.outFile[0] === recess.s.entry) {
            setting.outFile = setting.entry;
          }
          await recess.d.eachAsync(setting.outFile, async function(pth) {
            var out, rg, to;
            out = path.resolve(workdir, pth);
            to = recess.d.getExt(out);
            rg = recess.d.getType(files[0]);
            if (to !== rg) {
              files = (await recess.p.to(to, false)(files, cond));
            }
            await fs.remove(out);
            return (await fs.writeFile(out, files[0].contents, {
              mode: files[0].stat.stat.mode
            }));
          });
        } else if (files.length === 0) {

        } else if ((ref1 = setting.outDir) != null ? ref1.length : void 0) {
          out = setting.outDir || setting.outDirectory;
          // if there are multiple files, write they to directory, which specified in setting.outDir
          await recess.d.eachAsync(out, async function(dir) {
            return (await recess.d.eachAsync(files, async function(file) {
              var realPath;
              // absolute path
              realPath = path.resolve(workdir, dir, file.path);
              await fs.remove(realPath);
              await fs.mkdirp(path.dirname(realPath));
              await fs.writeFile(realPath, file.contents, {
                mode: files[0].stat.stat.mode
              });
            }));
          });
        }
        return files;
      });
    },
    outFile: function(setting) {
      if (!Array.isArray(setting)) {
        setting = [setting];
      }
      return async function(files, cond) {
        return (await plugin.pipes.write({
          outFile: setting
        })(files, cond));
      };
    },
    outDir: function(setting) {
      if (!Array.isArray(setting)) {
        setting = [setting];
      }
      return async function(files, cond) {
        return (await plugin.pipes.write({
          outDir: setting
        })(files, cond));
      };
    }
  };
  plugin.pipes.outDirectory = plugin.pipes.outDir;
  plugin.pipes.dest = plugin.pipes.write;
  plugin.pipes.load = plugin.pipes.add;
  plugin.pipes.mode = plugin.pipes.stat;
  plugin.pipes.remove = plugin.pipes.del;
  plugin.pipes.min = plugin.pipes.minify;
  plugin.pipes.if = plugin.pipes.cluster = plugin.pipes.pif;
  plugin.pipes.to = plugin.pipes.ex = plugin.pipes.convert;
  plugin.pipes.rename = plugin.pipes.concat;
  return plugin;
};
