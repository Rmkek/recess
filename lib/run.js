// Generated by CoffeeScript 2.1.1
var mm, uuid;

uuid = require('uuid/v1');

mm = require('micromatch');

module.exports = function(recess) {
  var getToRun, reporter, tasks;
  reporter = recess.reporter;
  recess._tasks = tasks = {};
  getToRun = function(ts) {
    var i, j, key, keys, len, len1, name, ret;
    ret = {};
    for (i = 0, len = ts.length; i < len; i++) {
      name = ts[i];
      if (typeof name === 'function') {
        ret[uuid()] = name;
        continue;
      } else if (typeof name === 'string') {
        keys = mm(Object.keys(tasks), [name]);
        for (j = 0, len1 = keys.length; j < len1; j++) {
          key = keys[j];
          ret[key] = tasks[key];
        }
        if (keys.length === 0) {
          reporter.tasksNotFound(ts);
        }
      }
    }
    return ret;
  };
  recess.task = recess.tasks = function(task) {
    return Object.assign(tasks, task);
  };
  recess.run = async function(ts) {
    var e, toRun;
    if (!Array.isArray(ts)) {
      ts = [ts];
    }
    toRun = getToRun(ts);
    try {
      return (await recess.d.eachAsync(toRun, async function(setting, name) {
        var cont, e;
        if (typeof setting === 'function') {
          cont = recess.collection([]);
          try {
            if (!~recess._services.indexOf(setting)) {
              reporter.startingTask(name);
              await (setting.call(cont));
              recess._services.push(setting);
              return reporter.finishedTask(name);
            }
          } catch (error) {
            e = error;
            return reporter.error(e);
          }
        } else {
          return (await recess._runTask(name, setting));
        }
      }));
    } catch (error) {
      e = error;
      return reporter.error(e);
    }
  };
  recess.watchTasks = async function(ts) {
    var e, toRun;
    if (!Array.isArray(ts)) {
      ts = [ts];
    }
    toRun = getToRun(ts);
    try {
      return (await recess.d.eachAsync(toRun, async function(setting, name) {
        if (typeof setting === 'function') {
          return reporter.cantWatch(name);
        } else {
          return (await recess._watchTask(name, setting));
        }
      }));
    } catch (error) {
      e = error;
      return reporter.error(e);
    }
  };
  recess.startRun = async function() {
    reporter.start();
    reporter.usingConfig(recess.filename);
    await recess.run(...arguments);
    if (!recess.alive) {
      return reporter.end();
    }
  };
  recess.startWatch = async function() {
    reporter.startWatch();
    reporter.usingConfig(recess.filename);
    recess.d.keepAlive();
    return (await recess.watch(...arguments));
  };
  recess.seq = recess.sequence = function() {
    var r, tsks;
    tsks = recess.d.flat(arguments);
    r = async function() {
      var i, len, results, task;
      results = [];
      for (i = 0, len = tsks.length; i < len; i++) {
        task = tsks[i];
        results.push((await recess.run(task)));
      }
      return results;
    };
    r[recess.s.isSequence] = true;
    return r;
  };
  return recess.e = recess.event = function(f) {
    var r;
    r = function() {
      return f();
    };
    r[recess.s.isEvent] = true;
    return r;
  };
};
