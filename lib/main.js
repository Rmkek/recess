// Generated by CoffeeScript 2.0.2
//##################
// CONNECT MODULES #
//##################
var bufferize, chalk, config, cwd, del, deps, exists, fs, getExt, getType, glob, isBuffer, mdeps, mkdirp, parallel, path, process, punk, reporter, rr, setImmediate, stp, type, util;

process = require('process');

path = require('path');

fs = require('fs');

util = require('util');

mkdirp = require('mkdirp');

glob = require('glob');

parallel = require('run-parallel');

chalk = require('chalk');

mdeps = require('module-deps');

stp = require('stream-to-promise');

isBuffer = require('is-buffer');

del = require('del');

type = require('file-type');

rr = require('require-resolve');

reporter = require('./reporter.js');

//###################
// DEFINE VARIABLES #
//###################
cwd = process.cwd();

config = process.mainModule.filename;

//##########################
// DEFINE HELPER FUNCTIONS #
//##########################
exists = function(pth) {
  try {
    fs.accessSync(pth);
    return true;
  } catch (error1) {
    return false;
  }
};

setImmediate = setImmediate || function(f) {
  return setTimeout(f, 0);
};

deps = function(file) {
  return new Promise(function(resolve, reject) {
    var md;
    md = mdeps();
    stp(md).then(function(file) {
      return resolve(file);
    });
    return md.end({file});
  });
};

bufferize = function(files) {
  var file, name, results;
  results = [];
  for (name in files) {
    file = files[name];
    if (!isBuffer(file)) {
      results.push(files[name] = Buffer.from(file));
    } else {
      results.push(void 0);
    }
  }
  return results;
};

getExt = function(name = '') {
  var ext;
  ext = path.extname(name).split('.');
  return ext[ext.length - 1];
};

getType = function(name, file) {
  var ext, tp;
  tp = type(file);
  if (!tp) {
    tp = {
      ext: getExt(name)
    };
  }
  return ext = tp.ext;
};

//########
// START #
//########
punk = {
  filename: config,
  dirname: path.dirname(config),
  //######
  // RUN #
  //######
  run: function(settings) {
    var fn, funcs, name, setting, start;
    reporter.start();
    reporter.usingConfig(config);
    if (settings.entry) {
      settings = [settings];
    }
    start = async function(taskName, setting, cb) {
      var contents, e, entry, files, i, j, k, keys, len, len1, len2, name, out, p, paths, pipe, pth, realPath, ref, ref1, rg, to, workdir;
      if (setting.pipes == null) {
        //#####################################
        // TRANSFORM SETTING TO STANDARD FORM #
        //#####################################
        setting.pipes = [];
      }
      if (!Array.isArray(setting.pipes)) {
        setting.pipes = [setting.pipes];
      }
      if (!Array.isArray(setting.entry)) {
        setting.entry = [setting.entry];
      }
      files = [];
      if (setting.workdir) {
        workdir = setting.workdir;
      } else {
        workdir = './';
      }
      reporter.startingTask(taskName);
      ref = setting.entry;
      //#############
      // FIND FILES #
      //#############
      for (i = 0, len = ref.length; i < len; i++) {
        entry = ref[i];
        if (!entry) {
          continue;
        }
        try {
          // get path
          paths = glob.sync(entry, {
            cwd: workdir
          });
          for (j = 0, len1 = paths.length; j < len1; j++) {
            pth = paths[j];
            // read file
            contents = fs.readFileSync(path.resolve(workdir, pth));
            files[pth] = contents;
          }
        } catch (error1) {}
      }
      ref1 = setting.pipes;
      //###########################
      // PASS FILES THROUGH FILES #
      //###########################
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        pipe = ref1[k];
        if (!pipe) {
          continue;
        }
        try {
          p = pipe(files);
          if (p instanceof Promise) {
            p.catch(function(e) {
              return reporter.error(e);
            });
            files = (await p);
          } else {
            files = p;
          }
          p = bufferize(p);
        } catch (error1) {
          e = error1;
          reporter.error(e);
        }
      }
      
      //##########
      // CONVERT #
      //##########
      to = setting.outFormat || setting.outExtension || setting.outEx || setting.to;
      if (to) {
        try {
          p = punk.to(to)(files);
          if (p instanceof Promise) {
            p.catch(function(e) {
              return reporter.error(e);
            });
            files = (await p);
          } else {
            files = p;
          }
          p = bufferize(p);
        } catch (error1) {
          e = error1;
          reporter.error(e);
        }
      }
      
      //########
      // WRITE #
      //########
      keys = Object.keys(files);
      if ((keys.length === 1) && (setting.outFile != null)) {
        out = setting.outFile;
        to = getExt(path.resolve(workdir, out));
        rg = getType(keys[0], files[keys[0]]);
        if (to !== rg) {
          try {
            p = punk.to(to)(files);
            if (p instanceof Promise) {
              p.catch(function(e) {
                return reporter.error(e);
              });
              files = (await p);
            } else {
              files = p;
            }
            p = bufferize(p);
          } catch (error1) {
            e = error1;
            reporter.error(e);
          }
        }
        
        // if there is a single file, write its contents to path, which specified in setting.outFile
        del(path.resolve(workdir, setting.outFile));
        fs.writeFileSync(path.resolve(workdir, setting.outFile), files[keys[0]]);
      } else if (keys.length === 0) {

      } else {
        out = setting.outDir || setting.out || './';
        // if there are multiple files, write they to directory, which specified in setting.outDir
        for (name in files) {
          contents = files[name];
          // absolute path
          realPath = path.resolve(workdir, out, name);
          if (exists(realPath)) {
            // remove existing file
            del(realPath);
          }
          mkdirp.sync(path.dirname(realPath));
          fs.writeFileSync(realPath, contents);
        }
      }
      reporter.finishedTask(taskName);
      return cb();
    };
    //##############
    // START BUILD #
    //##############
    funcs = [];
    // isolate task from current scope.
    // if this is not done, errors like https://javascript.info/task/make-army can happen
    // there are no "let" in coffeescript, so this is only way
    fn = function(name, setting) {
      return funcs.push(function(cb) {
        var t;
        t = start(name, setting, cb);
        return t.catch(function(error) {
          return reporter.error(error);
        });
      });
    };
    for (name in settings) {
      setting = settings[name];
      fn(name, setting);
    }
    return parallel(funcs, function() {
      reporter.finishedAll();
      return reporter.end();
    });
  },
  reporter: reporter,
  // PLUGINS USAGE #
  plugins: {},
  converters: {},
  minifiers: {},
  _use: function(plugin) {
    var name, ref, value;
    if (typeof plugin === 'function') {
      plugin = plugin(punk, reporter);
    }
    if (plugin.pipes) {
      ref = plugin.pipes;
      for (name in ref) {
        value = ref[name];
        if (punk.p[name]) {
          reporter.error(punk.errors.pluginsConflict(name));
        } else {
          if (Array.isArray(value)) {
            value.textInput = true;
            punk.p[name] = value[0];
          } else {
            punk.p[name] = value;
          }
        }
      }
    }
    if (plugin.converters) {
      Object.assign(punk.converters, plugin.converters);
    }
    if (plugin.minifiers) {
      return Object.assign(punk.minifiers, plugin.minifiers);
    }
  },
  use: function() {
    var name, plugin, plugins, results;
    if (arguments.length > 1) {
      plugins = arguments;
    } else if (Array.isArray(arguments[0])) {
      plugins = arguments[0];
    } else {
      plugins = [arguments[0]];
    }
    results = [];
    for (name in plugins) {
      plugin = plugins[name];
      results.push(punk._use(plugin));
    }
    return results;
  },
  // ERRORS #
  errors: {
    pluginsConflict: function(pluginName) {
      var pl;
      pl = chalk.blue(pluginName);
      return new Error('Plugin "' + pl + '" conflicts with existing plugin "' + pl + '"!');
    }
  }
};

punk.p = punk.plugins;

module.exports = punk;

//####################
// ADD BASIC PLUGINS #
//####################
punk.use([require('./plugins/bundle.js'), require('./plugins/mute.js'), require('./plugins/converter.js'), require('./plugins/minifier.js'), require('./plugins/concat.js')]);

//##########
// ALIASES #
//##########
punk.to = punk.convert = punk.ex = punk.p.convert;

punk.min = punk.minify = punk.p.minify;
