// Generated by CoffeeScript 2.0.2
var fs, mdeps, path, setImmediate, stp, svg, type;

mdeps = require('module-deps');

fs = require('fs');

path = require('path');

type = require('file-type');

stp = require('stream-to-promise');

svg = require('is-svg');

({setImmediate} = require('timers'));

module.exports = function(punk, reporter) {
  var d;
  d = {
    // CHECK FILE EXISTANCE #
    exists: function(pth) {
      try {
        fs.accessSync(pth);
        return true;
      } catch (error) {
        return false;
      }
    },
    // GET DEPENDENCIES OF JS FILE #
    deps: function(file) {
      return new Promise(function(resolve, reject) {
        var md;
        md = mdeps();
        stp(md).then(function(file) {
          return resolve(file);
        });
        return md.end({file});
      });
    },
    // BUFFERIZE FILES #
    bufferizeFiles: function(files) {
      var file, name;
      for (name in files) {
        file = files[name];
        files[name] = Buffer.from(file);
      }
      return files;
    },
    toPromise: function(f) {
      if (f instanceof Promise) {
        return f;
      } else {
        return new Promise(function(resolve, reject) {
          var e;
          try {
            return resolve(f);
          } catch (error) {
            e = error;
            return reject(e);
          }
        });
      }
    },
    // GET EXTNAME OF FILE #
    getExt: function(name = '') {
      var ext;
      ext = path.extname(name).split('.');
      return ext[ext.length - 1];
    },
    // GET TYPE OF FILE #
    getType: function(name, file) {
      var ext, tp;
      tp = type(file);
      if (!tp) {
        tp = {
          ext: d.getExt(name)
        };
      }
      ext = tp.ext;
      try {
        if (svg(file)) {
          ext = 'svg';
        }
      } catch (error) {}
      return ext;
    },
    // difference between this functions is that getExt just returns extname, but getType returns true type of file
    // e.g. you can rename pic.png to pic.jpg
    // getExt will say that format is jpg
    // but getType will say that format is png
    // use getType, it's better

    // ASYNC MAP FOR PROMISES #
    mapAsync: function(obj, func, cb = function() {}) {
      return new Promise(function(resolve, reject) {
        var ir, name, results, results1, value;
        ir = Array.isArray(obj);
        if (ir) {
          results = [];
        } else {
          results = {};
        }
        if (obj.length === 0) {
          resolve(results);
        }
        results1 = [];
        for (name in obj) {
          value = obj[name];
          if (ir) {
            name = name - 0;
          }
          results1.push((function(name, value) {
            // async call
            return setImmediate(async function() {
              var r;
              r = func(value, name);
              if (r instanceof Promise) {
                r.catch(function(err) {
                  return reporter.error(err);
                });
              }
              results[name] = (await r);
              if (Object.keys(obj).length === Object.keys(results).length) {
                return resolve(results);
              }
            });
          })(name, value));
        }
        return results1;
      });
    },
    eachAsync: function(obj, func, cb = function() {}) {
      return new Promise(function(resolve, reject) {
        var finished, name, results1, tasks, value;
        tasks = 0;
        finished = 0;
        results1 = [];
        for (name in obj) {
          value = obj[name];
          if (ir) {
            name = name - 0;
          }
          results1.push((function(name, value) {
            tasks++;
            return setImmediate(async function() {
              var r;
              r = func(value, name);
              if (r instanceof Promise) {
                r.catch(function(err) {
                  return reporter.error(err);
                });
              }
              results[name] = (await r);
              finished++;
              if (tasks === finished) {
                return resolve(results);
              }
            });
          })(name, value));
        }
        return results1;
      });
    },
    toSetting: function(inp) {
      var i, item, len, r, setting;
      // array to object
      if (Array.isArray(inp)) {
        r = {};
        for (i = 0, len = inp.length; i < len; i++) {
          item = inp[i];
          if (typeof item === 'object') {
            Object.assign(r, item);
          } else if (typeof item === 'function') {
            if (r.pipes == null) {
              r.pipes = [];
            }
            r.pipes.push(item);
          }
        }
        setting = r;
      } else {
        setting = inp;
      }
      if (setting.pipes == null) {
        setting.pipes = setting.pipe || setting.pipeline || [];
      }
      if (!Array.isArray(setting.pipes)) {
        setting.pipes = [setting.pipes];
      }
      if (setting.entry == null) {
        setting.entry = setting.entries || setting.input || setting.inputs || [];
      }
      setting.workdir = setting.workdir || setting.dir || setting.dirname || './';
      if (setting.workdir) {
        setting.workdir = path.resolve(punk.dirname, setting.workdir);
      } else {
        setting.workdir = path.resolve(punk.dirname);
      }
      return setting;
    }
  };
  return {
    dev: d
  };
};
