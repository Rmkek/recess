// Generated by CoffeeScript 2.0.2
var net, path, setImmediate, stp, type;

path = require('path');

type = require('file-type');

stp = require('stream-to-promise');

net = require('net');

({setImmediate} = require('timers'));

module.exports = function(punk) {
  var d, reporter;
  reporter = punk.reporter;
  d = {
    // CHECK FILE EXISTANCE #
    exists: function(pth) {
      try {
        fs.accessSync(pth);
        return true;
      } catch (error) {
        return false;
      }
    },
    // # GET DEPENDENCIES OF JS FILE #
    // deps: (file) ->
    // 	new Promise (resolve, reject) ->
    // 		md = mdeps()

    // 		stp(md).then (file) ->
    // 			resolve file

    // 		md.end({ file })
    prepareFiles: function(files) {
      var file, index, results1;
      results1 = [];
      for (index in files) {
        file = files[index];
        if (!file) {
          results1.push(files.splice(index, 1));
        } else {
          results1.push(file.contents = Buffer.from(file.contents));
        }
      }
      return results1;
    },
    toPromise: function(f) {
      if (f instanceof Promise) {
        return f;
      } else {
        return new Promise(function(resolve, reject) {
          var e;
          try {
            return resolve(f);
          } catch (error) {
            e = error;
            return reject(e);
          }
        });
      }
    },
    // GET EXTNAME OF FILE #
    getExt: function(name = '') {
      var ext;
      ext = path.extname(name).split('.');
      return ext[ext.length - 1];
    },
    // GET TYPE OF FILE #
    getType: function(file) {
      var ext, tp;
      tp = type(file.contents);
      if (!tp) {
        tp = {
          ext: d.getExt(file.path)
        };
      }
      ext = tp.ext;
      try {
        if (d.isSvg(file.contents)) {
          ext = 'svg';
        }
      } catch (error) {}
      return ext;
    },
    // keep process alive
    keepAlive: function() {
      return net.createServer().listen();
    },
    // difference between this functions is that getExt just returns extname, but getType returns true type of file
    // e.g. you can rename pic.png to pic.jpg
    // getExt will say that format is jpg
    // but getType will say that format is png
    // use getType, it's better

    // ASYNC MAP FOR PROMISES #
    mapAsync: function(obj, func, cb = function() {}) {
      return new Promise(function(resolve, reject) {
        var ir, name, results, results1, value;
        ir = Array.isArray(obj);
        if (ir) {
          results = [];
        } else {
          results = {};
        }
        if ((obj.length === 0) || (Object.keys(obj).length === 0)) {
          resolve(results);
        }
        results1 = [];
        for (name in obj) {
          value = obj[name];
          if (ir) {
            name = name - 0;
          }
          results1.push((function(name, value) {
            // async call
            return setImmediate(async function() {
              var r;
              r = func(value, name);
              if (r instanceof Promise) {
                r.catch(function(err) {
                  return reporter.error(err);
                });
              }
              results[name] = (await r);
              if (Object.keys(obj).length === Object.keys(results).length) {
                return resolve(results);
              }
            });
          })(name, value));
        }
        return results1;
      });
    },
    eachAsync: function(obj, func, cb = function() {}) {
      return new Promise(function(resolve, reject) {
        var finished, name, results1, tasks, value;
        tasks = 0;
        finished = 0;
        if ((obj.length === 0) || (Object.keys(obj).length === 0)) {
          resolve();
        }
        results1 = [];
        for (name in obj) {
          value = obj[name];
          results1.push((function(name, value) {
            tasks++;
            return setImmediate(async function() {
              var r;
              r = func(value, name);
              if (r instanceof Promise) {
                r.catch(function(err) {
                  return reporter.error(err);
                });
              }
              await r;
              finished++;
              if (tasks === finished) {
                return resolve();
              }
            });
          })(name, value));
        }
        return results1;
      });
    },
    toSetting: function(inp) {
      var item, k, len1, r, setting;
      // array syntax to object
      if (Array.isArray(inp)) {
        r = {};
        for (k = 0, len1 = inp.length; k < len1; k++) {
          item = inp[k];
          if (typeof item === 'object') {
            Object.assign(r, item);
          // add event
          } else if ((typeof item === 'function') && item[punk.s.isEvent]) {
            if (r.start == null) {
              r.start = [];
            }
            r.start.push(item);
          // add pipe
          } else if ((typeof item === 'function') && !item[punk.s.isSequence]) {
            if (r.pipes == null) {
              r.pipes = [];
            }
            r.pipes.push(item);
          // add sequence
          } else if ((typeof item === 'function') && item[punk.s.isSequence]) {
            if (r.start == null) {
              r.start = [];
            }
            r.start.push(item);
          // add another task
          } else if (typeof item === 'string') {
            if (r.start == null) {
              r.start = [];
            }
            r.start.push(item);
          }
        }
        setting = r;
      } else {
        setting = inp;
      }
      if (setting.pipes == null) {
        setting.pipes = setting.pipe || setting.pipeline || [];
      }
      if (!Array.isArray(setting.pipes)) {
        setting.pipes = [setting.pipes];
      }
      if (setting.start == null) {
        setting.start = setting.start || setting.trigger || setting.trig || [];
      }
      if (!Array.isArray(setting.start)) {
        setting.start = [setting.start];
      }
      if (setting.entry == null) {
        setting.entry = setting.entries || setting.input || setting.inputs || [];
      }
      setting.workdir = setting.workdir || setting.dir || setting.dirname || './';
      if (setting.workdir) {
        setting.workdir = path.resolve(punk.dirname, setting.workdir);
      } else {
        setting.workdir = path.resolve(punk.dirname);
      }
      return setting;
    },
    isSvg: function(s) {
      var comments, svg;
      comments = /<!--([\s\S]*?)-->/gi;
      svg = /^\s*(?:<\?xml[^>]*>\s*)?(?:<!doctype svg[^>]*\s*(?:<![^>]*>)*[^>]*>\s*)?<svg[^>]*>[^]*<\/svg>\s*$/i;
      return svg.test(s.toString().replace(comments, ''));
    },
    sleep: function(time) {
      return new Promise(function(r, j) {
        return setTimeout(function() {
          return r();
        }, time);
      });
    },
    flat: function(f) {
      var flat;
      flat = function(arr, res) {
        var cur, i, len;
        i = 0;
        cur = void 0;
        len = arr.length;
        while (i < len) {
          cur = arr[i];
          if (Array.isArray(cur)) {
            flat(cur, res);
          } else {
            res.push(cur);
          }
          i++;
        }
        return res;
      };
      return flat(f, []);
    }
  };
  return punk.dev = d;
};
