// Generated by CoffeeScript 2.0.2
var net, path, setImmediate, stp, type;

path = require('path');

type = require('file-type');

stp = require('stream-to-promise');

net = require('net');

({setImmediate} = require('timers'));

module.exports = function(punk) {
  var d, reporter;
  reporter = punk.reporter;
  d = {
    // CHECK FILE EXISTANCE #
    exists: function(pth) {
      try {
        fs.accessSync(pth);
        return true;
      } catch (error) {
        return false;
      }
    },
    // # GET DEPENDENCIES OF JS FILE #
    // deps: (file) ->
    // 	new Promise (resolve, reject) ->
    // 		md = mdeps()

    // 		stp(md).then (file) ->
    // 			resolve file

    // 		md.end({ file })
    prepareFiles: function(files) {
      var file, index, results1;
      results1 = [];
      for (index in files) {
        file = files[index];
        if (!file) {
          results1.push(files.splice(index, 1));
        } else {
          results1.push(file.contents = Buffer.from(file.contents));
        }
      }
      return results1;
    },
    toPromise: function(f) {
      if (f instanceof Promise) {
        return f;
      } else {
        return new Promise(function(resolve, reject) {
          var e;
          try {
            return resolve(f);
          } catch (error) {
            e = error;
            return reject(e);
          }
        });
      }
    },
    // GET EXTNAME OF FILE #
    getExt: function(name = '') {
      var ext;
      ext = path.extname(name).split('.');
      return ext[ext.length - 1];
    },
    // GET TYPE OF FILE #
    getType: function(file) {
      var ext, tp;
      tp = type(file.contents);
      if (!tp) {
        tp = {
          ext: d.getExt(file.path)
        };
      }
      ext = tp.ext;
      try {
        if (d.isSvg(file.contents)) {
          ext = 'svg';
        }
      } catch (error) {}
      return ext;
    },
    // keep process alive
    keepAlive: function() {
      return net.createServer().listen();
    },
    // difference between this functions is that getExt just returns extname, but getType returns true type of file
    // e.g. you can rename pic.png to pic.jpg
    // getExt will say that format is jpg
    // but getType will say that format is png
    // use getType, it's better

    // ASYNC MAP FOR PROMISES #
    mapAsync: function(obj, func, cb = function() {}) {
      return new Promise(function(resolve, reject) {
        var ir, name, results, results1, value;
        ir = Array.isArray(obj);
        if (ir) {
          results = [];
        } else {
          results = {};
        }
        if (obj.length === 0) {
          resolve(results);
        }
        results1 = [];
        for (name in obj) {
          value = obj[name];
          if (ir) {
            name = name - 0;
          }
          results1.push((function(name, value) {
            // async call
            return setImmediate(async function() {
              var r;
              r = func(value, name);
              if (r instanceof Promise) {
                r.catch(function(err) {
                  return reporter.error(err);
                });
              }
              results[name] = (await r);
              if (Object.keys(obj).length === Object.keys(results).length) {
                return resolve(results);
              }
            });
          })(name, value));
        }
        return results1;
      });
    },
    eachAsync: function(obj, func, cb = function() {}) {
      return new Promise(function(resolve, reject) {
        var finished, name, results1, tasks, value;
        tasks = 0;
        finished = 0;
        results1 = [];
        for (name in obj) {
          value = obj[name];
          results1.push((function(name, value) {
            tasks++;
            return setImmediate(async function() {
              var r;
              r = func(value, name);
              if (r instanceof Promise) {
                r.catch(function(err) {
                  return reporter.error(err);
                });
              }
              await r;
              finished++;
              if (tasks === finished) {
                return resolve();
              }
            });
          })(name, value));
        }
        return results1;
      });
    },
    toSetting: function(inp) {
      var i, item, len, r, setting;
      // array to object
      if (Array.isArray(inp)) {
        r = {};
        for (i = 0, len = inp.length; i < len; i++) {
          item = inp[i];
          if (typeof item === 'object') {
            Object.assign(r, item);
          } else if (typeof item === 'function') {
            if (r.pipes == null) {
              r.pipes = [];
            }
            r.pipes.push(item);
          }
        }
        setting = r;
      } else {
        setting = inp;
      }
      if (setting.pipes == null) {
        setting.pipes = setting.pipe || setting.pipeline || [];
      }
      if (!Array.isArray(setting.pipes)) {
        setting.pipes = [setting.pipes];
      }
      if (setting.entry == null) {
        setting.entry = setting.entries || setting.input || setting.inputs || [];
      }
      setting.workdir = setting.workdir || setting.dir || setting.dirname || './';
      if (setting.workdir) {
        setting.workdir = path.resolve(punk.dirname, setting.workdir);
      } else {
        setting.workdir = path.resolve(punk.dirname);
      }
      return setting;
    },
    isSvg: function(s) {
      var comments, svg;
      comments = /<!--([\s\S]*?)-->/gi;
      svg = /^\s*(?:<\?xml[^>]*>\s*)?(?:<!doctype svg[^>]*\s*(?:<![^>]*>)*[^>]*>\s*)?<svg[^>]*>[^]*<\/svg>\s*$/i;
      return svg.test(s.toString().replace(comments, ''));
    }
  };
  return punk.dev = d;
};
