// Generated by CoffeeScript 2.1.1
var deasync, net, path, setImmediate, type;

path = require('path');

type = require('file-type');

net = require('net');

({setImmediate} = require('timers'));

deasync = require('deasync');

module.exports = function(recess) {
  var d, reporter;
  reporter = recess.reporter;
  d = {
    // CHECK FILE EXISTANCE #
    exists: function(pth) {
      try {
        fs.accessSync(pth);
        return true;
      } catch (error) {
        return false;
      }
    },
    // # GET DEPENDENCIES OF JS FILE #
    // deps: (file) ->
    // 	new Promise (resolve, reject) ->
    // 		md = mdeps()

    // 		stp(md).then (file) ->
    // 			resolve file

    // 		md.end({ file })
    prepareFiles: function(files) {
      var file, index, results1;
      results1 = [];
      for (index in files) {
        file = files[index];
        if (!file) {
          results1.push(files.splice(index, 1));
        } else {
          results1.push(file.contents = Buffer.from(file.contents));
        }
      }
      return results1;
    },
    toPromise: function(f) {
      if (f instanceof Promise) {
        return f;
      } else {
        return new Promise(function(resolve, reject) {
          var e;
          try {
            return resolve(f);
          } catch (error) {
            e = error;
            return reject(e);
          }
        });
      }
    },
    // GET EXTNAME OF FILE #
    getExt: function(name = '') {
      var ext;
      ext = path.extname(name).split('.');
      return ext[ext.length - 1];
    },
    // GET TYPE OF FILE #
    getType: function(file) {
      var ext, tp;
      tp = type(file.contents);
      if (!tp) {
        tp = {
          ext: d.getExt(file.path)
        };
      }
      ext = tp.ext;
      try {
        if (d.isSvg(file.contents)) {
          ext = 'svg';
        }
      } catch (error) {}
      return ext;
    },
    // keep process alive
    keepAlive: function() {
      if (!recess.alive) {
        net.createServer().listen();
      }
      return recess.alive = true;
    },
    // difference between this functions is that getExt just returns extname, but getType returns true type of file
    // e.g. you can rename pic.png to pic.jpg
    // getExt will say that format is jpg
    // but getType will say that format is png
    // use getType, it's better

    // ASYNC MAP FOR PROMISES #
    mapAsync: function(obj, func) {
      return new Promise(function(resolve, reject) {
        var name, results, results1, value;
        if (Array.isArray(obj)) {
          results = [];
        } else {
          results = {};
        }
        if ((obj.length === 0) || (Object.keys(obj).length === 0)) {
          resolve(results);
        }
        results1 = [];
        for (name in obj) {
          value = obj[name];
          results1.push((function(name, value) {
            // async call
            return setImmediate(async function() {
              var r;
              r = func(value, name);
              if (r instanceof Promise) {
                r.catch(function(err) {
                  return reporter.error(err);
                });
              }
              results[name] = (await r);
              if (Object.keys(obj).length === Object.keys(results).length) {
                return resolve(results);
              }
            });
          })(name, value));
        }
        return results1;
      });
    },
    eachAsync: function() {
      return this.mapAsync(...arguments);
    },
    toSetting: function(inp) {
      var item, k, len1, r, setting;
      // array syntax to object
      if (Array.isArray(inp)) {
        r = {};
        for (k = 0, len1 = inp.length; k < len1; k++) {
          item = inp[k];
          if (typeof item === 'object') {
            Object.assign(r, item);
          // add event
          } else if ((typeof item === 'function') && item[recess.s.isEvent]) {
            if (r.start == null) {
              r.start = [];
            }
            r.start.push(item);
          // add pipe
          } else if ((typeof item === 'function') && !item[recess.s.isSequence]) {
            if (r.pipes == null) {
              r.pipes = [];
            }
            r.pipes.push(item);
          // add sequence
          } else if ((typeof item === 'function') && item[recess.s.isSequence]) {
            if (r.start == null) {
              r.start = [];
            }
            r.start.push(item);
          // add another task
          } else if (typeof item === 'string') {
            if (r.start == null) {
              r.start = [];
            }
            r.start.push(item);
          }
        }
        setting = r;
      } else {
        setting = inp;
      }
      if (setting.pipes == null) {
        setting.pipes = setting.pipe || setting.pipeline || [];
      }
      if (!Array.isArray(setting.pipes)) {
        setting.pipes = [setting.pipes];
      }
      setting.start = setting.start || setting.trigger || setting.trig || setting.then || [];
      if (!Array.isArray(setting.start)) {
        setting.start = [setting.start];
      }
      setting.needs = setting.needs || setting.need || setting.deps || setting.dep || setting.depend || setting.depends || setting.dependOn || setting.dependsOn || setting.invoke || setting.invokes;
      if (!Array.isArray(setting.start)) {
        setting.needs = [setting.start];
      }
      if (setting.entry == null) {
        setting.entry = setting.entries || setting.input || setting.inputs || [];
      }
      if (!Array.isArray(setting.entry)) {
        setting.entry = [setting.entry];
      }
      if (setting.outFile == null) {
        setting.outFile = setting.outFiles || [];
      }
      if (!Array.isArray(setting.outFile)) {
        setting.outFile = [setting.outFile];
      }
      if (setting.outDir == null) {
        setting.outDir = setting.outDirs || [];
      }
      if (!Array.isArray(setting.outDir)) {
        setting.outDir = [setting.outDir];
      }
      setting.workdir = setting.workdir || setting.dir || setting.dirname || './';
      if (setting.workdir) {
        setting.workdir = path.resolve(recess.dirname, setting.workdir);
      } else {
        setting.workdir = path.resolve(recess.dirname);
      }
      return setting;
    },
    isSvg: function(s) {
      var comments, svg;
      comments = /<!--([\s\S]*?)-->/gi;
      svg = /^\s*(?:<\?xml[^>]*>\s*)?(?:<!doctype svg[^>]*\s*(?:<![^>]*>)*[^>]*>\s*)?<svg[^>]*>[^]*<\/svg>\s*$/i;
      return svg.test(s.toString().replace(comments, ''));
    },
    sleep: function(time) {
      return new Promise(function(r, j) {
        return setTimeout(function() {
          return r();
        }, time);
      });
    },
    flat: function(f) {
      var flat;
      flat = function(arr, res) {
        var cur, i, len;
        i = 0;
        cur = void 0;
        len = arr.length;
        while (i < len) {
          cur = arr[i];
          if (Array.isArray(cur)) {
            flat(cur, res);
          } else {
            res.push(cur);
          }
          i++;
        }
        return res;
      };
      return flat(f, []);
    },
    await: function(p) {
      var finished, r;
      finished = false;
      r = void 0;
      p.then(function(rs) {
        finished = true;
        return r = rs;
      });
      deasync.loopWhile(function() {
        return !finished;
      });
      return r;
    },
    once: (function() {
      var did;
      did = [];
      return async function(f, args = [], context) {
        if (!did.indexOf(f)) {
          if (context) {
            await f.apply(context, args);
          } else {
            await f(...args);
          }
          return did.push(f);
        }
      };
    })(),
    beep: function() {
      return process.stdout.write('\u0007');
    }
  };
  recess.dev = d;
  return recess.d = d;
};
